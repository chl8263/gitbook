# ch12. 다형성

## 1. 다형성

다형성 : 여러 타입을 대상으로 동작할 수 있는 코드를 작성할 수 있는 방법

* 다형성
  * 유니버설
    * 매개변수 : 클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식.

        제레닉

    * 포함 : 메시지가 동일 하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력.

        서브 클래스의 메서드가 동작하는 방식
  * 임시
    * 오버로딩 : 하나의 클래스 안에 동일한 아름의 메서드가 존재하는 경우

        유사한 작업을 수행하는 메서드의 이름을 통일할 수 있기 때문에 기억해야 하는 이름의 수를 극적으로 줄일 수 있다.

    * 강제 : 언어가 지원하는 자동적인 타입 변환이나 사용자가 직접 구현하는 타입변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식.

        ex\) "asb" + 12

## 2. 상속의 양면성

객체지향 프로그램을 작성하지 위해서는 항상 `데이터`와 `행동` 이라는 두 가지 관점을 함께 고려해야함

상속의 목적은 코드 재사용이 아닌 프로그램을 구성하는 개념들을 기반으로 다형성을 가능하게 하는 타입 계층을 구축하기 위한 것이다.

상속의 메커니즘을 이해하는데 필요한 개념들

* 업캐스팅
* 동적 메서드 탐색
* 동적 바인딩
* self참조
* super참조

{% hint style="danger" %}
상속을 사용하는 일차적인 목표는 코드 재사용성이 아니다.
{% endhint %}

### 데이터 관점에서의 상속

상속을 인스턴스 관점에서 바라볼 때는 개념적으로 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스가 포함되는 것으로 생각하는 것이 유용하다. 

인스턴스를 참조하는 lecture는 GradeLecture의 인스턴스를 가리키기 때문에 특별한 방법을 사용하지 않으면 GradeLecture 안에 포함된 Lecture의 인스턴스에 직접 접근할 수 없다.

![](../../.gitbook/assets/image%20%2827%29.png)

테이터 관점에서 상속은 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는것.

### 행동 관점에서의 상속

행동 관점의 상속 : 부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것

메서드 오버라이딩, 오버로딩 또는 부모의 메서드를 사용하는 등 상속은 부모와 자식 클래스간에 메서드 공유가 가능하다.

어떻게 부모 클래스에서 구현한 메서드를 자식 클래스에서 사용할까? 자식 인스턴스가 만들어질때 메서드를 합치거나 복사를 하는 것일까?

그 이유는 런타임에 시스템이 자식 클래스에 정의되지 않은 메서드가 있을 경우 이 메서드를 부모 클래스 안에서 탐색한다.

객체의 경우에는 서로 다른 상태를 저장할 수 있도록 각 인스턴스 별로 독립적인 메모리를 할당 받아야 한다. 하지만 메서드의 경우에는 동일한 클래스의 인스턴스끼리 공유가 가능하기 때문에 `클래스는 단 한번만 메모리에 로드하고 각 인스턴스별로 클래스를 가리키는 포인터를 갖게 하는것이 경제적`이다.

![&#xD074;&#xB798;&#xC2A4;&#xC640; &#xC778;&#xC2A4;&#xD134;&#xC2A4;&#xC758; &#xAC1C;&#xB150;&#xC801;&#xC778; &#xAD00;&#xACC4;](../../.gitbook/assets/image%20%2828%29.png)

위 그림의 두 인스턴스는 동일한 Lecture class에 대한 pointer를 가지고 Lecture 또한 상위 클래스 `Object` 에 대해 `parent` 라는 포인터를 가진다.

고로 메세지를 수신한 객체는 class포인터로 연결된 자신의 클래스에 적절함 메서드가 존재하는지를 찾고 만약 메서드가 존재하지 않으면 클래스의 `parent` 포인터를 따라 부모 클래스를 차례대로 훑어 가면서 적절한 메서드가 존재하는지를 검사한다.

### 업케스팅

* 업케스팅 : 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것

```java
Lecture lecture = new GradeLecture();
```

상속시에 부모 클래스의 퍼블릭 인터페이스가 자식 클래스의 퍼블릭 인터페이스에 합쳐지기 때문에 부모 클래스의 인스턴스에게 전송할 수 있는 메시지를 자식 클래스의 인스턴스에게 전송할 수 있다.

이는 다형성을 가능하게 한다.

반대로 부모 클래스의 인스턴스를 자식 클래스 타입으로 변환하는 것을 `다운 캐스팅` 이라고 한다.

```java
GradeLecture gradeLecture = new Lecture();
```

![](../../.gitbook/assets/image%20%2829%29.png)

## 3. 업캐스팅과 동적 바인딩

### 업케스팅

* 업케스팅 : 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것

```java
Lecture lecture = new GradeLecture();
```

상속시에 부모 클래스의 퍼블릭 인터페이스가 자식 클래스의 퍼블릭 인터페이스에 합쳐지기 때문에 부모 클래스의 인스턴스에게 전송할 수 있는 메시지를 자식 클래스의 인스턴스에게 전송할 수 있다.

반대로 부모 클래스의 인스턴스를 자식 클래스 타입으로 변환하는 것을 `다운 캐스팅` 이라고 한다.

```java
GradeLecture gradeLecture = new Lecture();
```

### 동적 바인딩

* 정적 바인딩, 초기 바인딩, 컴파일 타임 바인딩 : 컴파일 타임에 호출할 함수를 결정하는 방식
* 동적 바인딩, 지연 바인딩 : 실행될 메소드를 런타임에 결정하는 방식

객체지향 언어가 제공하는 업캐스팅과 동적 바인딩을 이용하면 부모 클래스 참조에 대한 메시지 전송을 자식 클래스에 대한 메서드 호출로 변환할 수 있다.

## 4. 동적 메서드 탐색과 다형성

객체가 메세지를 수신하면 컴파일러는 `self` 메서드 참조라는 임시 변수를 자동으로 생성한 후 메시지를 수신한 객체를 가리키도록 설정한다.

`동적 메서드 탐색은`은 self가 가리키는 객체의 클래스에서 시작해서 상속 계층의 역방향으로 이뤄지면 메소드 탐색이 종료되는 순간 self참조는 자동으로 소멸된다.

메서드 탐색은 자식 클래스에서 부모 클래스의 방향으로 진행된다. 따라서 자식 클래스에 선언된 메서드가 부모 클래스에 메서드보다 더 높은 우선순위를 가진다.

![](../../.gitbook/assets/image%20%2823%29.png)

### 동적인 문맥

메시지를 수신한 객체가 무엇이냐에 따라 메서드 탐색을 위한 문맥이 동적으로 바뀐다는 것이다. 그리고 이 동적인 문맥을 결정하는 것이 `self 참조`다.

self 참조가 종적 문맥을 결정하는데 있어서 어떤 메시지를 실행하게 하게 하는것이 `self 전송` 이다.

`self 전송`은 어떤 `객체에게 메세지를 전송`하게 하는 역할을 한다.

아래의 코드에서 `status()` 메서드는 `getEvaluationMethod()` 메서드를 호출한다.

하지만 코드가 실행되는 `self 전송` 관점에서 **getEvaluationMethod\(\)** 메서드를 `실행하는 것이 아닌` `self가 가리키는 현재 객체에게 메시지를 전송하는 것`이다.

```java
public class Lecture{
    public String status() {
        return "Evaluation Method : " + getEvaluationMethod();
    }

    public String getEvaluationMethod() {
        return "Pass or Fail";
    }
}
```

![](../../.gitbook/assets/image%20%2824%29.png)

### 이해할 수 없는 메시지

만약 상속 계층에서 `self 참조`가 메시지를 찾지 못하였을 경우에는?

정적 타입 언어 에서는 컴파일 에러를 발생 시키지만 동적인 언어에서는 최상위 클래스 까지 이르게 되고 최종적으로 예외가 던져짐.

![](../../.gitbook/assets/image%20%2830%29.png)

### self 대 super

self 참조는 메시지를 수신한 객체의 클래스에 따라 메서드 탐색을 위한 문맥을 실행 시점에 결정한다. super 는 `부모 메서드를 호출` 하는 용도가 아니라 `지금 이 클래스의 부모 클래스를 탐색 하라`이다.

## 5. 상속 대 위임

self 참조가 동적인 문맥을 결정하는데, 자식 클래스에서 부모 클래스로 self 참조를 전달하는 메커니즘으로 상속을 바라보자.

{% hint style="info" %}
#### self 참조는 항상 메시지를 수신한 객체를 가리킨다.
{% endhint %}

![](../../.gitbook/assets/image%20%2826%29.png)

위의 그림의 GradeLecture\(자식\) 와 그 안에 Lecture\(부모\) 클래스 모두 동일한 self 참조를 가진다. \(수신 객체가 GradeLecture 의 메서드를 호출했을 경우\)

자신이 수신한 메세지를 다른 객체에게 동일하게 전달해서 처리를 요청하는 것을 `위임` 이라고 한다. 

{% hint style="info" %}
**위임**은 본질적으로 자신이 정의하지 않거나 처리할 수 없는 속성 또는 메서드의 탐색 과정을 다른 객체에게 이동시키기 위해 사용한다.

**포워드**는 위임의 특성과 달리 그저 단순히 코드를 재사용의 목적으로만 다른 객체에 처리를 요청할 때 사용한다. \(self 참조 가 없으므로 다형성, 상속 등 의 목적이 아님\)
{% endhint %}

### 프로토타입 기반의 객체지향 언어

### 프로토 타입이란?

{% hint style="info" %}
프로토타입 기반 언어는 클래스 기반 언어에서 상속을 사용하는 것과는 다르게, 객체를 원형\(프로토타입\)으로 하는 복제 과정을 통해 객체의 동작 방식을 재사용 할 수 있게 한다.
{% endhint %}

![](../../.gitbook/assets/image%20%2822%29.png)

프로토타입 기반 언어는 원형 객체를 복제하여 새로운 객체를 하는 생성하는 언어를 말한다.

대표적으로 자바 스크립트가 프로토 타입 언어지만, 자바스크립트는 약간 다르다. 

복제가 아닌 프로토타입 링크를 통해 원형을 참조한다.

Javascript는 원시타입, 문자열, 숫자, 불리언, null, undefined 을 제외하면 모든것이 `객체` 이다. 즉 배열도 함수도 객체인 것이Z

 자바스크립트에서 객체는 원형 객체로 부터 생성되며, 생성된 객체는 원형에 대한 프로토타입 링크\(`__proto__`\)를 갖게 된다.

원형 또한 객체이기 때문에 원형은 또 다른 원형을 참조하게 되고, 다음 그림과 같이 연속된 프로토타입 링크를 통해 자바스크립트 객체의 최종 원형인 `Object.prototype`까지 연결된다.  


![](../../.gitbook/assets/image%20%2831%29.png)

 자바스크립트에서는 객체 속성에 접근하게 되면 해당 객체의 속성들만 탐색한 후 결과를 반환하는 것이 아니라, 최종 원형인 `Object.prototype`까지 탐색한 후 결과를 반환한다.

```java
const Lecture = function(name, scores) {
    this.name = name;
    this.scores = scores;
}

Lecture.prototype.stats = function() {
    return "LECTURE !! stats"
}

Lecture.prototype.getEvaluationMethod = function() {
    return "LECTURE !! getEvaluationMethod"
}

const GrandLecture = function(name, scores) {
    this.name = name;
    this.scores = scores;
}

GrandLecture.prototype = new Lecture();

GrandLecture.prototype.getEvaluationMethod = function() {
    return "GrandLecture !! getEvaluationMethod " + this.name;
}

const g = new GrandLecture("ewan", 12)

console.log(g.getEvaluationMethod());
console.log(g.stats());

>> GrandLecture !! getEvaluationMethod ewan
>> LECTURE !! stats
```

위의 코드 `GrandLecture.prototype = new Lecture();` 부분에 Lecture 타입으로 GrandLecture 의 프로토 타입을 선언한 것을 볼 수 있다.  이는 프로토 타입 체인을 걸은 것으로 하위 프로토 타입의 메서드 부터 시작해서 상위 메서드 까지 탐색을 진행하여 빨리 발견한 메서드를 실행함으로써 동적 메서드 탐색이 종료된다.

Prototype 언어는 정적인 상속관계가 아닌 동적인 `prototype chain` 으로 객체 사이에 위임을 통해 상속을 구현한다.

{% hint style="info" %}
객체지향은 객체를 지향하는 것이다. 클래스는 객체를 편하게 정의하고 생성하기 위해 제공되는 프로그래밍 구성 요소일 뿐이며 중요한 것은 메시지와 협력이다. 클래스 없이도 객체 사이의 협력 관계를 구축하는 것이 가능하며 상속 없이도 다형성을 구현하는 것이 가능하다.
{% endhint %}

