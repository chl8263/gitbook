# ch9. 유연한 설계

### 1. 개방-폐쇄 원칙

> 소프트웨어 개체는 확장에 열려있어야 하고, 수정에 대해서는 닫혀 있어야 한다.

* 확장에 대해 열려 있다 : 애플리 케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 '동작'을 추가해서 애플리케이션의 기능을 확장할 수 있다.
* 수정에 대해 닫혀 있다: 기존의 '코드'를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.

#### 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라

개방-폐쇄 원칙은 런타임 의존성과 컴파일타임 의존성에 관한 이야기다. 런타임 의존성이 많은 코드일수록 개방-폐쇄 원칙을 잘 지킨다고 할 수 있다.

따라서 개방-폐쇄 원칙의 핵심은 **추상화**에 의존하는 것이다. 추상화는 수정에 대해 **닫혀**있고 추상화를 통해 생략된 부분에 대해서는 **확장**의 여지를 남긴다. 수정에 대한 영향을 최소화 하기 위해서는 모든 요소가 추상화에 의존해야 한다.

### 2. 생성 사용 분리

결합도가 높아질수록 개방-폐쇄 원칙을 따라는 구조를 설계하기가 어려워진다.(알아야 하는 지식이 많으면 결합도가 높아짐)

객체의 타입과 생성자에 전달해야 하는 인자에 대한 과도한 지식은 코드를 특정한 컨텍스트에 강하게 경합시킨다. 컨텍스트를 바꾸기 위한 유일한 방법은 코드 안에 명시돼 있는 컨텍스트에 대한 정보를 직접 수정하는 것뿐이다.

```java
public class Mvoie{
    private DiscountPolicy discountPolicy;

    public Movie(....) {
        this.discountPolicy = new AmountDiscountPolicy(....);
    }

    public calculate(){
        this.discountPolicy.calculate(..);
    }
}
```

위의 Movie의 코드를 보면 생성자 안에서 인스턴스를 생성하고 calculate 메서드 안에서 이 객체에게 메시지를 전송한다.

객체를 생성하는게 문제가 아니라 적시적소의 상황에 맞게 객체를 생성하는것이 핵심이다.

메시지를 전송하지 않고 객체를 생성하기만 했다면 괜찮았을 것이다. 혹은 객체를 생성하지 않고 메시지만 전송 했다면 괜찮았을 것이다. 동일한 클래스 안에서 객체 생성과 사용이라는 두 가지 이질적인 목적을 가진 코드가 공존하는 것이 문제인 것이다.

유연하고 재사용 가능한 설께를 원한다면 객체와 관련된 두 가지 책임을 서로 다른 객체를 분리해야 한다. 하나는 객체를 생성하는 것이고, 다른 하나는 객체를 사용하는 것이다.

한 마디로 말해서 객체에 대한 **생성과 사용을 분리**한다.

#### FACTORY 추가하기

위의 코드를 향상하기 위해 아래와 같이 Client class를 만들고 생성과 사용을 분리 하였다.

```java
public class Client{
    public Money getAvatarFee(){
        Movie avatar = new Movie(
            ...,
            ...,
            new AmountDiscountPolicy(...)
        );

        return avatar.getFee();
    }    
}
```

하지만 getAvatarFee 메서드 안에서도 Movie 를 생성하고 getFee 메서드를 사용하는 것을 볼 수 있다. 이것또한 **생성과 사용을 분리**원칙을 위반한다.

이 경우 객체 생성과 관련된 책임만 전담하는 별도의 객체를 추가하고 Client는 이 객체를 사용하도록 만들 수 있다. 이처럼 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체를 FACTORY라고 부른다.

```java
public class Factory{
    public Movie createAvatarMovie(){
        return new Movie(
            ...,
            ...,
            new AmountDiscountPolicy(...)
        );
    }    
}

public class Client{
    private Factory factory;

    public Client(Factory factory) {
        this.factory = factory;
    }

    public Money getAvatarFee(){
        Movie avatar = factory.createAvatarMovie();
        return avatar.getFee();
    }    
}
```

#### 순수 가공물에게 책임 할당하기

시스템을 객체로 분해하는 데는 크게 2가지 방법이 있다.

1. 표현적 분해 : 도메인에 존재하는 사물 또는 개념을 표현하는 객체들을 이용해 시스템을 분해하는 것, 도메인 모델에 감겨 있는 개념과 관계를 따르며 도메인과 소프트웨어 사이의 표현적 차이를 최소화하는 것을 목적으로 한다. 객체지향 설계를 위한 가장 기본적인 접근법
2. 행위적 분해 : 책임을 할당하기 위해 창조되는 도메인과 무관한 인공적인 객체로 분해하는것

하지만 종종 도메인 개념을 표현하는 객체에게 책임을 할당하는 것만으로는 부족한 경우가 발생한다.

**도메인 모델은 설게를 위한 중요한 출발점이지만 단지 출발점이라는 사실을 명심해야 한다.**

모든 책음을 도메인 객체에세 할당하면 낮은 응집도, 높은 결합도, 재사용성 저하와 같은 심각한 문제점에 봉착하게 된다.

이런 측면에서 객체지향이 실세계의 모방이라는 말은 옳지 않다. 객체지향 러플리케이션은 도메인 개념뿐만 아니라 설계자들이 임의로 창조한 개념을 반영하는 객체보다 오히려 더 많은 비중을 차지하는 것이 일반적이다.

### 3. 의존성 주입

* 의존성 주입 : 외부의 독립적인 객체가 인스턴스를 생성 후 이를 전달해서 의존성을 해결하는 방법

필요한 의존성은 클래스의 퍼블릭 인터페이스에 명시적으로 드러내게하여 객체의 캡슐을 단단하게 보호하라.

### 4. 의존성 역전 원칙

객체 사이의 협력이 존재할 때 그 협력의 본질은 담고 있는 것은 상위 수준의 정책이다. 어떤 협력에서 중요한 정책이나 의사결정, 비즈니스의 본질을 담고 있는 것은 상위 수준의 클래스이다. 그러나 상위 수준의 클래스가 하위 수준의 클래스에 의존한다면 하위 수준의 변경에 의해 상위 수준 클래스가 영향을 받게 된다.

```
상위 ---> 하위 (X)

상위 <--- 하위 (O)
```

1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.
2. 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.

> > 의존성 역전 원칙 에서 '역전'이라는 말은 전통적인 프로그래밍에서 상위가 하위에 의존하는 경향이 많아서 그런것이다.

#### 의존성 원칙과 패키지

![](<../../.gitbook/assets/image (14).png>)

다음과 같이 Movie 패키지 따로, DiscountPolicy 상위 클래스와 하위클래스가 합쳐진 패키지가 따로 있으면 컴파일 할 때 DiscountPolicy의 하위 클래스가 바뀔때 마다 DiscountPolicy의 패키지가 재 컴파일 될것이고 그에따라 Movie 패키지 또한 재 컴파일이 되어야 한다. Movie에 의존하는 또 다른 패키지가 있다면 컴파일을 의존성의 그래프를 타고 애플리케이션 코드 전체로 번져갈 것이다.

![](<../../.gitbook/assets/image (13).png>)

따라서 위의 그림과 같이 추상화를 별도의 독립적인 패키지가 아니라 클라이언트가 속한 패키지에 포함시켜야 한다. 그리고 재사용될 필요가 없는 클래스들은 별도의 독립적인 패키지에 모아야 한다.

의존성 역전 원칙에 따라 상위 수준의 협력 흐름을 재사용하기 위해서는 추상화가 제공하는 인터페이스의 소유권 역시 역전시켜야 한다.

### 5. 유연성에 대한 조언

유연성은 항상 복잡성 수반한다. 유연하지 않은 설계는 단순하고 명확하다. 유연한 설계는 복잡하고 암시적이다. 불필요한 유연성은 불필요한 복잡성을 낳는다. 단순하고 명확한 해법이 그런대로 만족스럽다면 유연성을 제거하라. 유연성은 코드를 읽는 사람들이 복잡함을 수용할 수 있을 때만 가치가 있다. 하지만 복잡성에 대한 걱정보다 유연하고 재사용 가능한 설게의 필요성이 더 크다면 코드의 구조와 실행 구조를 다르게 만들어라.

의존성을 관리해야 하는 이유는 역할, 책임, 협력의 관점에서 설계가 유연하고 재사용 가능해야 하기 때문이다. 따라서 역할, 책임, 협력에 먼저 집중해야 한다. 역할, 책임, 협력의 모습이 선명하게 그려지지 않는다면 의존성을 관리하는 데 들이는 모든 노력이 물거품이다.
