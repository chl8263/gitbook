# ch4.설계 품질과 트레이드오프



### 1. 데이터 중심의 영화 예매 시스템

객체지향 설계에서는 두 가지 방법을 이용해 시스템을 객체로 분할할 수 있다. 

1. **상태를 분할의 중심축으로 삼는 방법** 
2. **책임을 분할의 붕심축으로 삼는 방법**

책임을 분할의 중심축으로 삼는 방법으로 해야 좋은 설계다.

객체의 상태는 구현에 속한다, 구현은 불안정하기 때문에 변경이 쉽다. 하지만 객체의 책임은 인터페이스에 속한다. 객체는 책임을 드러내는 안정적인 인터페이스 뒤로 책임을 수행하는 데 필요한 상태를 캡슐화함으로써 구현 변경에 대한 파장이 외부로 퍼져나가는 것을 방지한다.

데이터 중신의 설계한 객체내부에 저장되는 데이터를 기반으로 시스템을 분할하는 방법이다. 책임 중심의 설계가 '책임이 무엇인가' 를 묻는 것으로 시작한다면 데이터 중심의 설계는 객체가 내부에 저장해야 하는 '데이터가 무엇인가'를 묻는 것으로 시작한다.

### 2. 설계 트레이드오프 

캡슐화, 응집도, 결합도 의 품질 척도의 의미

* 캡슐화 

> 상태와 행동을 하나의 객체 안에 모으는 이유는 객체의 내부 구현을 외부로부터 감추기 위해서이다. 객체지향이 강력한 이유는 한 곳에서 일어난 변경이 전체 시스템에 영향을 끼치지 않도록 파급효과를 조절 할 수 있는기때문 변경될 가능성이 높은 부분을 구현 이라고 부르고 상대적으로 안정적인 부분을 인터페이스하고 부른다. 가장 기본적인 아이디어는 변경의 정도에 따라 구현과 인터페이스를 분리하고 외부에서는 인터페이스에만 의존하도록 하는것. 캡슐화는 외부에서 알 필요가 없느 ㄴ부분을 감춤으로써 대상을 다순화하는 추상화의 한 종류이다. 설계가 필요한 이유는 요구사항이 변경되기 때문이고, 캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리해서 변경의 영향을 통제할 수있기 때문이다.

* 응집도 

> 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다. 모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 그 모듈은 높은 응집도를 가진다. 객체지향의 관점에서 응집도는 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는지를 나타냄.

* 결합도 

> 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도. 어떤 모듈이 다른 모듈에 대해 너무 자세한 부분까지 알고 있다면 두 모듈은 높은 결합도를 가짐.

결합도가 높아도 상관없는 경우가 있다. 

일반적으로 변경될 확률이 매우 적은 안정적인 모듈에 의존하는 것은 아무런 문제도 되지 않는다. 표준 라이브러리에 포함된 모듈이나 성숙 단계에 접어든 프레임워크에 의존하는 것은 아무런 문제도 되지않는다. 예를들어 Java의 String, ArrayList는 변경될 확률이 매우 낮기 때문에 결합도에 대해 고민할 필요가 없다.

응집도와 결합도눈 변경과 관련이 깊다. 어떤 설게를 쉽게 변경할 수 있다면 높은 응집도를 가지는 것이고 요소들 사이에 결합도가 낮을 확률이 높다. 캡슐화의 정도가 응집도와 결합도에 영향을 미친다. 캡슐화를 지키면 응집도는 높아지도 결합도는 낮아진다.

### 3. 데이터 중심의 영화 예매 시스템의 문제점

```text
public class Movie {
    private Money fee;
    
    public Money getFee(){
        return this.fee;
    }
    
    public void setFee(Money fee){
        this.fee = fee;
    }
}
```

위의 코드에서 fee를 getter, setter를 이용해서 구현했으니 캡슐화를 잘 지켰다고 볼 수 있을까? 결과적으로 객체의 상태를 public 인터페이스에 노골적으로 드러내고 있고 메서드가 책임 위주로 설계된것이 아닌 데이터 위주로 설계됨. 이처럼 접근자와 수정자에 과도하게 의존하는 설계 방식을 **'추측에 의한 설계 전략'** 이라고 부른다. 프로그래머는 외부에 모든 상태를 노출시키고 그 결과, 캡슐화릐 원칙을 위반하는 변경에 취약한 설계를 얻게 된다.

> 단일 책임의 원칙 : 클래스는 단 한 가지의 변경 이유만 가져야 한다.

### 4. 자율적인 객체를 향해

어떤 객체의 상태를 외부에서 setter로 설정하지말고 객체안에서 스스로 책임을 지게하는것이 중요.

### 5. 캡슐화의 진정한 의미

* 캡슐화가 단순히 객체 내부의 데이터를 외부로 감추는 것 이상의 의미를 가진다는 것을 보여준다. 캡슐화는 변경될 수 있는 모든것을 감추는것이다.



* 높은 결합도 

```text
public class Movie{
	public boolean .....{
		for(DiscountCondition condition : discountCondition){
		
			if(condition.getType() == DiscountConditionType.PERIOD){
				...
			}
			else if(condition.getType() == DiscountConditionType.AMOUNT){
				...
			}
			.....
			.....
		}
	}
}
```

위의 코드에서 discount condition 이 변경된다면?? Movie에서 discount condition 에 대해 직접적으로 사용하고 있으므로 Movie까지 수정해야 한다. 이는 두 객체 사이에 결합도가 높다는 의미이다.

### 6. 데이터 중심 설계의 문제점

데이터 중심의 설계가 변경에 취약한 이유

* 데이터 중심의 설계는 본질적으로 어무 이른 시기에 데이터에 관해 결정하도록 강요한다.
* 데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.

데이터 중심의 설계는 접근자와 수정자를 과도하게 추가하게되고 이는 결국 캡슐화를 완전히 무너지게함. 데이터를 먼저 결정하고 데이터를 처리하는 데 필요한 오퍼레이션을 나중에 결정하는 방식은 데이터에 관한 지식이 객체의 인터페이스에 고스란히 드러나게 된다. 결론적으로 데이터 중심의 설계는 너무 이른 시기에 데이터에 대해 고민하기 때문에 캡슐화에 실패하게 된다.

올바른 객체지향 설계의 묵게 중심은 항상 객체의 내부가 아니라 외부에 초점이 맞춰져야한다. 객체가 내부에 어떤 상태를 가지고 그 상태를 어떻게 관리하는가는 부가적인 내용이다. 중요한것을 객체가 다른 객체와 협력하는 방법이다.

데이터 중심의 설계는 어떤가? 내부에 초점이 맞춰져있다. 객체의 구현이 이미 결정된 상태에서 다른 객체와의 협력 방법을 고민하기 때문에 이미 구현된 인터페이스를 억지로 끼워맞출 수 밖에 없다.

