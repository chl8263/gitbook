# ch6. 코틀린 타입 시스템

코틀린의 타입 시스템은 코드의 가독성을 향상시키는 데 도움이 되는 `널이 될 수 있는 타입`과 `읽기 전용 타입`이 있다.

## 1. 널 가능성

코틀린은 `NULL 이 될 수 있는지 여부`를 `타입 시스템에 추가`함으로써 컴파일러가 여러가지 오류를 런타임이 아닌 `컴파일 타임`에 감지해서 실행 시점에 발생할 수 있는 예외의 가능성을 줄일 수 있다.

기본적인 코틀린의 타입은 null이 될 수 없는 타입이다.

```kotlin
fun strLen(s: String){
    return s.length()
}
```

`strLen` 메서드에 널이 될 수 있는 타입은 들어올 수 없다.

`null 이 될 수 있는` 타입은 따로 설정해 주어야 한다.

```kotlin
fun strLen(s: String?){
    ...
}
```

타입 이름 뒤에 `?`를 붙여 사용한다. 이는 어떤 타입이든 뒤에 `?`가 오면 그 타입의 변수나 프로퍼티에 null 참조를 저장할 수 있다는 뜻이다.

`?` 가 붙는 변수에 직접 `.()` 같은 메서드 호출을 할 수 없고 `null 참조 변수`와 `null 참조하지 않는 변수` 는 서로 대입하거나 할 수 없다.

하지만`null 참조하는 변수`를 null 가능성을 검사한다면 가능하다.

```kotlin
fun strLen(s: String?){
    if(s != null){
        s.length()
    }
}
```

## 안전한 호 연산자 : ?.

`?.`은 null 검사와 메소드 호출을 한 번의 연산으로 수행한다.

예를들어 `s?.length()` 는 `if(s != null) s.length() else null` 과 같다.

즉, 호출하려는 값이 null이 아니라면 `?.`은 일반 메소드 호출처럼 작동한다. 아니면 호출하려는 값이 무시되고 null이 결과값이 된다.

결국 `?.`또한 `null이 될 수 있는` 타입일 수 있음에 주의하라.

## 엘비스 연산자: ?:

코틀린은 null대신 사용할 디폴트 값을 지정할 때 `?:`라는 `엘비스`연산자를 사용한다.

```kotlin
fun foo(s: String?){
    return s ?: "default"
}
```

s 가 null 이면 "default" 문자를 출력한다.

## 안전한 캐스트: as?

타입을 as로 캐스트 하지 못하면 exception이 발생한다.

이때 `as?` 를 사용하면 exception이 아니면 null을 반환한다.

안전한 캐스트를 사용할 때 보통 `?:`엘비스 연산자와 같이 쓰는 패턴을 주를 이룬다.

## null 아님 단언: !!

컴파일러에게 어떤 변수는 null이나라고 직접 알려줄 수있다. 이 경우 실제 null이면 null exception 이 발생한다.

```kotlin
fun strLen(s: String?) {
    return s!!.length()
}
```

!! 기호는 컴파일러에게 나는 이 값이 null이 아님을 잘 알고 있고, 이 잘못에 대해서는 내가 감수하겠다 라는 의미다.

## let 함수

`let 함수`는 자신의 수신 객체를 인자로 전달받은 람다에게 넘긴다.

이때 안전한 호출 연산자와 함께 사용한다면 `null`을 검사하고 바로 결과를 변수에 넣는 작업을 할 수 있다.

```kotlin
var email: String? = "chl8263@naver.com"

email?.let{
    println(email)
}
```

## 나중에 초기화할 프로퍼티

코드를 작성하다 보면 프로퍼티를 나중에 작성해야 하는 경우가 생긴다. 이때 `var a = null` 같이 null을 먼저 대입하거나 해야한다. 코틀린에서는 `lateinit` 변경자를 붙여 프로퍼티를 나중에 초기화할 수 있다.

```kotlin
private lateinit var name: String

fun test(){
    name = "ewan"
}
```

`나중에 초기화 하는 프로퍼티는 항상 var` 이여야 한다. val 프로퍼티는 final 필드로 컴파일 되며, 생성자 안에서 반드시 초기화해야 한다.

lateinit 변경자를 붙였다 하더라도 초기화가 되기전에 참조하면 `exception`이 발생된다.

`null pointer exception` 보다 명확하고 훨씬 낫다.

## 타입 파라미터의 널 가능성

제네릭 `T` 사용은 null 가능성을 내포한다.

기본적으로 `T` 는 `Any?`타입이기 때문이다. 따라서 안전한 호출을 해주어야 한다.

```kotlin
fun <T> printHashCode(t: T) {
    print(t?.hashCode())
}
```

null 가능성을 배제하기 위해서 `타입 상한`을 지정해야한다.

```kotlin
fun <T: Any> printHashCode(t: T) {
    print(t.hashCode())
}
```

이제 이 메서드에 널 타입의 인자는 들어갈 수 없다.

{% hint style="info" %}
## 플랫폼 타입

코틀린은 자바와 상호 운용성을 위해 자바의 코드를 가져오는 경우 `플랫폼 타입` 으로 지정한다.

자바에서는 null 타입 강제성이 없기 때문에 이를 꼭꼭 유의해서 사용해야 한다.

코틀린에서는 플랫폼타입을 사용할 수 없고 단지 자바와 상호 운용성 때문에 존재함.
{% endhint %}

## 2. 코틀린의 원시타입

## 원시타입: Int, Boolean 등

자바는 `값이 직접 들어가는 원시 타입`과 `메모리상의 갹체 위치가 들어가는 참조 타입`을 구분한다.

따라서 자바의 원시타입은 그 값에 대해 메서드나 컬렉션에 원소를 담을 수 없어 Wrapper로 감싸주어야 한다.

코틀린에서는 원시타입과 래퍼 타입을 따로 구분하지 않는다.

{% hint style="info" %}
### 코틀린의 원시 타입은 객체이기 때문에 그럼 너무 비 효율적이지 않을까?

코틀린은 컴파일 시점에 해당 원시타입을 적절하게 자바의 원시 타입이든, 래퍼 타입이든 적절하게 알아서 바꾸어준다
{% endhint %}

자바의 원시타입에 해당하는 타입

* 정수 타입: Byte, Short, Int, Long
* 부동소수점 수 타입: Float, Double
* 문자 타입: Char
* 불리언 타입: Boolean

{% hint style="danger" %}
Int 와 같은 코틀린 타입에는 널 참조가 들어갈 수 없기 때문에 그에 상응하는 자바 원시 타입으로 컴파일할 수 있다. 

반대로 자바 원사타입은 결코 null이 될 수 없기 때문에 코틀린에서도 null이 아닌 타입\(플랫폼 타입이 아닌\) 으로 취급할 수 있다.
{% endhint %}

## 널아 될 수 없는 원시 타입: Int?, Boolean? 등

`Int?`, `Boolean?` 같은 널 타입은 코틀리에서는 어떻게 컴파일할까?

이때는 Java의 원시타입이 아닌 `java.lang.Integer`로 저장된다.

## 숫자변환

코틀린은 자바와 다르게 숫자를 자동으로 변환해 주지 않는다.

예를들어 코틀린의 아래 코드는 에러다.

```text
val i = 1
val l: Long = i // compile error
```

대신 직접 변환 메서드를 호출해야 한다.

```text
var i = 1
var l: Long = i.toLong()
```

코틀린은 모든 원시타입에 대한 변환 함수를 호출한다. `toChar()`, `toByte()` 등

## Any, Any?: 최상위 타입

자바에서 Object 가 최상위 타입이듯 코틀린에서는 `Any` 가 최상위 타입이다.

`val s: Any = 42` 이 코드는 Any 타입의 변수 이므로 자동으로 박싱이 된다.

## Unit 타입: 코틀린의 void

내용을 전혀 반환하지 않는 함수의 반환 타입으로 Unit을 쓸 수 있다.

```kotlin
fun f(): Unit {
    ...
}

fun f() {    // unit 을 생략해도 된다
    ...
}
```

자바의 void 와 달리 코틀린의 unit 은 Unit 타입을 인자로 쓸 수 있다. Unit 타입의 함수는 Unit 값을 묵시적으로 반환한다.

이 특성은 제네릭 파라메터를 반환하는 함수를 오버라이드 하면서 반환 타입으로 Unit을 쓸 때 유용하다.

```kotlin
interface Processor<T> {
    fun process() : T
}

class NoResultProcessor: Processor<Unit> {
    override fun process() {
        ...
    }
}
```

제네릭은 해당 타입을 반환하도록 강제한다. 따라서 Unit 타입이라면 딱히 반환할 필요가 없다.

{% hint style="info" %}
## Unit 의 유래

함수형 프로그래밍에서 전통적으로 Unit은 '단 하나의 인스턴스만 갖는 타입' 을 의미해 왔고 바로 그 유일한 인스턴스의 유무가 자바 void와 코틀린 Unit을 구분하는 가장 큰 차이다.
{% endhint %}

## 널 가능 컬렉션

![](../../.gitbook/assets/image%20%2821%29.png)

## 읽기 전용과 변경 가능한 컬렉션

코틀린 컬렉션과 자바 컬렉션의 중요 특정 차이는 코틀린 컬렉션 안의 데이터에 접근하는 인터펯이스와 컬렉션 안의 데이터를 변경하는 인터페이스를 분리했다는 점이다.

이런 구분은 `kotlin.collections.Collection` 부터 시작한다. 컬렉션에서 데이터를 읽는 여러 다른 연산을 수행할 수 있다.

컬렉션의 데이터를 수정하려면 `kotlin.collections.MutableCollection` 일반 인터페이스인 `kotlin.collections.Collection`을 확장한다.

![](../../.gitbook/assets/image%20%2820%29.png)



## 객체의 배열과 원시 타입의 배열

코틀린 배열은 타입 파라메터를 받는 클래스다.

배열의 원소 타입은 바로 그 타입 파라미터에 의해 정해진다.

코틀린에서 배열을 만드는 방법이다.

* arrayOf 함수에 원소를 넘기면 배열을 만들 수 있다.
* arrayOfNUll 함수에 정수 값을 인자로 넘기면 모든 원소가 null이고 인자로 넘긴 값과 크리가 같은 배열을 만들 수 있다. 물론 원소 타입이 널이 될 수 있는 타입인 경우에만 이 함수를 쓸 수 있다.
* Array 생성자는 배열 크기과 람다를 인자로 받아서 람다를 호출해서 각 배열 원소를 초기화해준다. arrayOf를쓰지 않고 각 원소가 널이 아닌 배열을 만들어야 하는 경 우 이 생성자를 사용한다.

아래 예제는 Array 생성자를 사용해 a부터 z 까지 26개의 알파벳 소문자에 해당하는 문자 배열을 만드는 코드이다.

```kotlin
val letters = Array<String>(26) { i -> ('a' + i).toString() }
```

## 요약

* 코틀린은 널이 될 수 있는 타입을 지원래 NullPointerException 오류를 컴팡리 시점에 감지할 수 있다.
* 코틀린의 안전한 호출\(?.\), 엘비스 연산자\(?:\), 널 아님 단언\(!!\), let 함수 등을 사용하면 널이 될 수 있는 타입을 간결한 코드로 다룰 수 있다.
* as? 연산자를 사용하면 값을 다른 타입으로 변환하는 것과 변환이 불가능한 경우를 처리하는 것을 한꺼번에 편리하게 처리할 수 있다.
* 자바에서 가져온 타입은 코틀린에서 플랫폼 타입으로 취급된다. 개발자는 플렛폼 타입을 널이 될 수 있는 타입으로도, 널이 될 수 없는 타입으로도 사용할 수 있다.
* 코틀린에서는 수를 표현하는 타입이 이반 클래스와 똑같이 생겼고 일반 클래스와 똑같이 동작한다. 하지만 대부분 컴파일러는 숫자 타입을 자바 원시 타입으로 컴파일한다.
* 널이 될 수 있는 원시타입 은 자바의 박싱한 원시타입에 대응한다.
* Any 타입은 다른 모든 타입의 조상 타입이며, 자바의 object에 해당한다. Unit 은 자바의 void와 비슷하다.
* 정상적으로 끝나지 않는 함수의 반환 타입을 지정할 때 Nothing 타입 사용한다.
* 코틀린 컬렉션은 표준 자바 컬렉션 클래스를 사용한다. 하지만 코틀린은 자바보다 컬렉션을 더 개선하서 읽기 전용 컬렉션과 변경 가능한 컬렉션을 구별해서 제공한다ㅑ.
* 자바 클래스를 코틀린에서 확장하거나 자바 인터페이스를 코틀린에서 구현하는 경우 메소드 파라미터의 널 가능성과 변경 가능성에 대해 깊이 생각해야 한다.
* 코틀린의 Array 클래스는 일반 제네릭 클래스처럼 보인다. 하지만 Array는 자바 배열로 컴파일 된다.
* 원시 타입의 배열은 IntArray 와 같이 각 타입에 대한 특별한 배열로 표현된다.

