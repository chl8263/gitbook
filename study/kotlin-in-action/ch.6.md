# ch.6 코틀린 타입 시스템

코틀린의 타입 시스템은 코드의 가독성을 향상시키는 데 도움이 되는 `널이 될 수 있는 타입`과 `읽기 전용 타입`이 있다.

## 1. 널 가능성

코틀린은 `NULL 이 될 수 있는지 여부`를 `타입 시스템에 추가`함으로써 컴파일러가 여러가지 오류를 런타임이 아닌 `컴파일 타임`에 감지해서 실행 시점에 발생할 수 있는 예외의 가능성을 줄일 수 있다.

기본적인 코틀린의 타입은 null이 될 수 없는 타입이다.

```kotlin
fun strLen(s: String){
    return s.length()
}
```

`strLen` 메서드에 널이 될 수 있는 타입은 들어올 수 없다.

`null 이 될 수 있는` 타입은 따로 설정해 주어야 한다.

```kotlin
fun strLen(s: String?){
    ...
}
```

타입 이름 뒤에 `?`를 붙여 사용한다. 이는 어떤 타입이든 뒤에 `?`가 오면 그 타입의 변수나 프로퍼티에 null 참조를 저장할 수 있다는 뜻이다.

`?` 가 붙는 변수에 직접 `.()` 같은 메서드 호출을 할 수 없고 `null 참조 변수`와 `null 참조하지 않는 변수` 는 서로 대입하거나 할 수 없다.

하지만`null 참조하는 변수`를 null 가능성을 검사한다면 가능하다.

```kotlin
fun strLen(s: String?){
    if(s != null){
        s.length()
    }
}
```

## 안전한 호 연산자 : ?.

`?.`은 null 검사와 메소드 호출을 한 번의 연산으로 수행한다.

예를들어 `s?.length()` 는 `if(s != null) s.length() else null` 과 같다.

즉, 호출하려는 값이 null이 아니라면 `?.`은 일반 메소드 호출처럼 작동한다. 아니면 호출하려는 값이 무시되고 null이 결과값이 된다.

결국 `?.`또한 `null이 될 수 있는` 타입일 수 있음에 주의하라.

## 엘비스 연산자: ?:

코틀린은 null대신 사용할 디폴트 값을 지정할 때 `?:`라는 `엘비스`연산자를 사용한다.

```kotlin
fun foo(s: String?){
    return s ?: "default"
}
```

s 가 null 이면 "default" 문자를 출력한다.

## 안전한 캐스트: as?

타입을 as로 캐스트 하지 못하면 exception이 발생한다.

이때 `as?` 를 사용하면 exception이 아니면 null을 반환한다.

안전한 캐스트를 사용할 때 보통 `?:`엘비스 연산자와 같이 쓰는 패턴을 주를 이룬다.

## null 아님 단언: !!

컴파일러에게 어떤 변수는 null이나라고 직접 알려줄 수있다. 이 경우 실제 null이면 null exception 이 발생한다.

```kotlin
fun strLen(s: String?) {
    return s!!.length()
}
```

!! 기호는 컴파일러에게 나는 이 값이 null이 아님을 잘 알고 있고, 이 잘못에 대해서는 내가 감수하겠다 라는 의미다.

## let 함수

`let 함수`는 자신의 수신 객체를 인자로 전달받은 람다에게 넘긴다.

이때 안전한 호출 연산자와 함께 사용한다면 `null`을 검사하고 바로 결과를 변수에 넣는 작업을 할 수 있다.

```kotlin
var email: String? = "chl8263@naver.com"

email?.let{
    println(email)
}
```

## 나중에 초기화할 프로퍼티

코드를 작성하다 보면 프로퍼티를 나중에 작성해야 하는 경우가 생긴다. 이때 `var a = null` 같이 null을 먼저 대입하거나 해야한다. 코틀린에서는 `lateinit` 변경자를 붙여 프로퍼티를 나중에 초기화할 수 있다.

```kotlin
private lateinit var name: String

fun test(){
    name = "ewan"
}
```

`나중에 초기화 하는 프로퍼티는 항상 var` 이여야 한다. val 프로퍼티는 final 필드로 컴파일 되며, 생성자 안에서 반드시 초기화해야 한다.

lateinit 변경자를 붙였다 하더라도 초기화가 되기전에 참조하면 `exception`이 발생된다.

`null pointer exception` 보다 명확하고 훨씬 낫다.

## 타입 파라미터의 널 가능성

제네릭 `T` 사용은 null 가능성을 내포한다.

기본적으로 `T` 는 `Any?`타입이기 때문이다. 따라서 안전한 호출을 해주어야 한다.

```kotlin
fun <T> printHashCode(t: T) {
    print(t?.hashCode())
}
```

null 가능성을 배제하기 위해서 `타입 상한`을 지정해야한다.

```kotlin
fun <T: Any> printHashCode(t: T) {
    print(t.hashCode())
}
```

이제 이 메서드에 널 타입의 인자는 들어갈 수 없다.

{% hint style="info" %}
## 플랫폼 타입

코틀린은 자바와 상호 운용성을 위해 자바의 코드를 가져오는 경우 `플랫폼 타입` 으로 지정한다.

자바에서는 null 타입 강제성이 없기 때문에 이를 꼭꼭 유의해서 사용해야 한다.

코틀린에서는 플랫폼타입을 사용할 수 없고 단지 자바와 상호 운용성 때문에 존재함.
{% endhint %}

## 2. 코틀린의 원시타입

## 원시타입: Int, Boolean 등

자바는 `값이 직접 들어가는 원시 타입`과 `메모리상의 갹체 위치가 들어가는 참조 타입`을 구분한다.

따라서 자바의 원시타입은 그 값에 대해 메서드나 컬렉션에 원소를 담을 수 없어 Wrapper로 감싸주어야 한다.

코틀린에서는 원시타입과 래퍼 타입을 따로 구분하지 않는다.

{% hint style="info" %}
### 코틀린의 원시 타입은 객체이기 때문에 그럼 너무 비 효율적이지 않을까?

코틀린은 컴파일 시점에 해당 원시타입을 적절하게 자바의 원시 타입이든, 래퍼 타입이든 적절하게 알아서 바꾸어준다
{% endhint %}

자바의 원시타입에 해당하는 타입

* 정수 타입: Byte, Short, Int, Long
* 부동소수점 수 타입: Float, Double
* 문자 타입: Char
* 불리언 타입: Boolean

{% hint style="danger" %}
Int 와 같은 코틀린 타입에는 널 참조가 들어갈 수 없기 때문에 그에 상응하는 자바 원시 타입으로 컴파일할 수 있다. 

반대로 자바 원사타입은 결코 null이 될 수 없기 때문에 코틀린에서도 null이 아닌 타입\(플랫폼 타입이 아닌\) 으로 취급할 수 있다.
{% endhint %}

## 널아 될 수 없는 원시 타입: Int?, Boolean? 등

`Int?`, `Boolean?` 같은 널 타입은 코틀리에서는 어떻게 컴파일할까?

이때는 Java의 원시타입이 아닌 `java.lang.Integer`로 저장된다.

## 숫자변환

코틀린은 자바와 다르게 숫자를 자동으로 변환해 주지 않는다.

예를들어 코틀린의 아래 코드는 에러다.

```text
val i = 1
val l: Long = i // compile error
```

대신 직접 변환 메서드를 호출해야 한다.

```text
var i = 1
var l: Long = i.toLong()
```

코틀린은 모든 원시타입에 대한 변환 함수를 호출한다. `toChar()`, `toByte()` 등

