# ch15. 디자인 패턴과 프레임워크

소프트웨어 설에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법을 `디자인 패턴`이라고 한다.

디자인 패턴의 목적은 설계를 재사용 하는것이다.

디자인 패턴이 협력을 일관성 있게 만들기 위해 재사용할 수 있는 설계의 묶음이라면, 프레임워크는 일관성 있는 협력을 제공하는 확장 가능한 코드다.

## 1. 디자인 패턴과 설계 재사용

### 소프트웨어 패턴

패턴이란?

* 패턴은 반복적으로 발하는 문제와 해법의 쌍으로 정의된다.
* 패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정이할 수 있으며, 이 지식을 다른 사람과 의사소통할 수 있다.
* 패턴은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적인 코드 작성을 돕는다.
* 패턴의 요점은 패턴이 실무에서 탄생했다는 점이다.

{% hint style="info" %}
많은 사람들이 패턴의 개념을 정립하는데, 마틴 파울러는 이렇게 정의한다.

실무 프로젝트가 패턴보다 먼저지만 그렇다고 해서 실무 프로젝트의 모든 아이디어가 패턴인 것은 아니다.

패턴은 개발자들이 다른 컨텍스트에서도 유용할 것이라고 생각하는 어떤 것이다.

마틴파울러의 &lt;Analysis Patterns&gt;
{% endhint %}

#### 3의 규칙  Rule of Three

* 패턴은 경험의 산물이며 치열한 실무 과정속에서 탄생한 검증되고 입증된 자산이다.
* 패턴은 지식 전달과 커뮤니케이션의 수단으로 활용할 수 있기 때문에 패턴에서 가장 중요한 요소는 패턴의 이름이다.
* 패턴의 범위가 소프트웨어 개발과 직접적인 연관성을 가진 분석, 설계, 구현 영역만으로 한정되는 것은 아니다. 프로젝트 조직을 구성하는 방법, 프로젝트 일정을 추가하는 방법, 스토리 카드나 백로그를 통해 요구사항을 관리하는 방법과 같이 반복적인 규칙을 발견할 수 있는 모든 영역에서 가능하다.
* 연관된 패턴들의 집합들이 모여 하나의 패턴 언어를 구성한다.

### 패턴 분류

패턴의 대분류

* 아키텍쳐 패턴
  * 소프트웨어의 전체적인 구조를 결정하기 위해 사용할 수 있는 패턴, 미리 정의된 서브시스템들을 제공하고, 각 서브시스템들의 책임을 정의하며, 서브시스템들 사이의 관계를 조직화하는 규칙과 가이드라인을 포함한다.
* 분석 패턴
  * 다른 3가지의 패턴들은 주로 기술적인 문제를 해결하는 데 초점을 맞추고 있다면, 분석 패턴은 도메인 내의 개념적인 문제를 해결하는 데 초점을 맞춘다. 분석패턴은 업무 모델링 시에 발견되는 공통적인 구조를 표현하는 개념들의 집합이다.
* 디자인 패턴
  * 특정 정황 내에서 일반적인 설계 문제를 해결하며, 협력하는 컴포넌트 사이에서 반복적으로 발생하는 구조를 서술한다.
* 이디엄
  * 디자인 패턴의 하위에 존재하며, 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴으로, 주어진 언어으 ㅣ기능을 사용해 컴포넌드, 혹은 컴포넌드 간의 측정 측면을 구현하는 방법을 서술한다.

### 패턴과 책임-주도 설계

책임과 협력의 윤곽은 캡슐화, 크기, 의존성, 유연성, 성능, 확장 가능성, 재사용성 등의 `다양한 요소들의 트레이트오프`를 통해 결정된다.

패턴은 공통적으로 사용할 수 있는 역할, 책임, 협력의 탬플릿이다.

패턴들의 세부적인 내용이 중요한 것이 아니라 중요한것은 패턴을 따름녀 특정한 상황에 적용할 수 있는 설계를 쉽고 빠르게 떠올릴 수 있다는 사실이다.

패턴을 잘 알고 있다면 책임 주도 설계의 절차를 하나하나 따르지 않고도 시스템 안에 구현할 객체들의 역할과 책임의 협력 관계를 빠르고 손쉽게 구성할 수 있다.

패턴의 기본 구조로부터 출발해서 현재의 요구에 맞게 구조를 수정해야 한다는것을 잊지말라.

### 캡슐화와 디자인 패턴

디자인 패턴은 협력을 일관성 있고 유연하게 만드는 것을 목적으로 한다. 따라서 각 디자인 패턴은 특정한 변경을 캡슐화하기 위한 독자적인 방법을 정의한다.

패턴의 목적은 알고리즘의 변경을 캡슐화하는 것이고 이를 구현하기 위해 객체 합성을 이용한다.

디자인 패턴에서 중용한 것은 패턴의 구현 방법이나 구조가 아니라 어떤 디자인 패턴이 어떤 변경을 캡슐화하는지를 이해하는지를 이해하는 것이 중요하다.

### 패턴은 출발점이다.

패턴은 그저 출발점이다. 디자인 패턴이 현재의 요구사항이나 적용기술, 프레임워크에 적합하지 않다면 패턴을 그대로 따르지 말고 목적에 맞게 패턴을 수정하라.

패턴을 처음 사용해보는 초보자는 패턴이 주는 강력함에 매료되어 아무리 사소한 설게라도 패턴을 적용해 보려고 시도한다. 그러나 명확한 트레이드오프 없이 패턴을 남용하면 설계가 불필요하게 복잡해진다.

정당한 이유없이 사용된 모든 패턴은 설계를 복잡하게 만드는 장애물이다. 패턴은 복잡성의 가치가 단순성을 넘어설 때만 정당화돼야 한다.

## 2. 프레임워크와 코드 재사용

### 코드 재사용 대 설계 재사용

재사용 관점에서 설계 재사용보다 더 좋은 방법은 코드 재사용이다. 개발자들은 컴포넌트를 조립해서 애플리케이션을 구현하는 방법을 사용했다. 컴포넌트 기반의 재사용 방법이라는 아이디어는 이상적이지만 실제로 적용하는 과정에서 현실적이지 않는다.

여러 프로젝트 사이에 비슷한 도메인이 존재한다면 유용하겠지만 실제로 그렇지 않다는 것이다.

가장 이상적인 형태의 재사용 방법은 설계 재사용과 코드 재사용을 적절한 수준으로 조합하는 것이다. 이것이 바로 프레임워크이다.

`프레임워크`란

* 추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계
  * 프레임워크의 구조적인 측면에 초점
* 애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격
  * 코드의 설계의 재사용 이라는 사용 목적



> 프레임워크는 애플리케이션에 대한 아키텍쳐를 제공한다. 즉, 프레임워크는 클래스와 객체들의 분할, 전체 구조, 클래스와 객체들간의 상호작용, 객체와 클래스 조합 방법, 제어 흐름에 대해 미리 정의한다. 프레임워크는 설계의 가변성을 미리 정의해 두었기 때문에 애플리케이션 설계자나 구현자는 애플리케이션에 종속된 부분에 대해서만 설계하면 된다. 프레임워크가 즉시 업무에 투입될 수 있는 구체적인 서브클래스를 포함하고 있기는 하지만 프레임워크는 코드의 재사용 보다는 설계의 재사용을 중요시한다.

### 상위 정책과 하위 정책으로 패키지 분리하기

상위 정책은 상대적으로 안정적이지만 세부 사항은 자주 변경된다.

의존성 원칙에 관점에서 세부 사항은 '변경'이다. 프레임워크는 여러 어플리케이션에 걸쳐 재사용 가능해야 하기 때문에 변하는 것과 변하지 않는 것들을 서로 다른 주기로 배포할 수 있도록 별도의 '배포 단위'로 분리해야 한다.

이를 위한 첫걸음은 변하는 부분과 변하지 않는 부분을 별도의 패키지로 분리하는 것이다.

![&#xC0C1;&#xC704; &#xC815;&#xCC45;&#xACFC; &#xD558;&#xC704; &#xC815;&#xCC45;&#xC744; &#xBCC4;&#xB3C4;&#xC758; &#xD328;&#xD0A4;&#xC9C0;&#xB85C; &#xBD84;&#xB9AC;](../../.gitbook/assets/image%20%2834%29.png)

중요한 것은 패키지 사이의 의존성 방향이다. 의존성 역전 원리에 따라 추상화에만 의존하도록 의존성의 방향을 조정하고 추상화를 경계로 패키지를 분리했기 때문에 세부 사항을 구현한 패키지는 항상 상위 정책을 구현한 패키지에 의존해야 한다.

상위 정책 패키지와 하위 정책 패키지를 물리적으로 완전히 분리하고 나면 상위 정책 패키지를 여러 애플리케이션에서 재사용할 수 있는 기반이 마련된 것이다. 다시말해 재사용 가능한 프레임워크가 만들어진 것이다.

동일한 프레임워크를 사용하는 애플리케이션은 구현 방식에 일관성이 있기 때문에 이해하기도 쉽다. 추가적으로 설계와 함께 코드 역시 재사용할 수 있다.

### 제어 역전의 원리

객체지향 설계의 재사용성은 개별 클래스가 아니라 객체들 사이의 공통적인 협력 흐름으로부터 나온다. 그리고 그 뒤에는 항상 의존성 역전 원리라는 강력한 지원군이 있다.

의존성 역전원리에 따르면 시스템은 협력흐름을 재사용할 수 있고, 변경에 유연하게 대처할 수도 있다.

