# 아파치 카프카란?

## 카프카의 탄생

kafka 는 각각의 래플리케이션끼리 연결하여 데이터를 처리하는 것이 아니라 한 곳에 모아 처리할  수 있도록 중앙집중화했다.

<figure><img src="../../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

## 아파치 카프카의 기본 구조

이제 소스 어플리케이션에서 생성된느 데이터는 어느 타깃 어플리케이션으로 보낼 것인지 도민하지 않고 일단 카프카로 넣으면 된다.

kafka 내부구조는 메세지 큐 구조를 그대로 가져간다.

<figure><img src="../../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

Topic : DB 의 테이블과 같은 개념. 구분하고하자는 것에 대한 것

Partition : 1\~N 개 의 파티션을 가지는 토픽을 만들 수 있다. 하나의 토픽에 메세지를 보내면 해당 토픽에 <mark style="color:red;">**하나의 파티션에서만 적재**</mark>가 된다. 파티션은 PIPO 방식의 큐 자료구조와 유사하게 동작한다.

Producer : 메세지를 보내는 역할

consumer : 컨슈머가 데이터를 가져갈 때 해당 토픽의 파티션에 PIPO 방식으로 하나씩 가져간다. 여기서 중요한 것은 컨슈머가 데이터를 가져가도 파티션의 큐 에서는 데이터가 날라가지 않는다는 것이다. 해당 컨슈머는 commit 을 이용해 해당 토픽의 몇번째 파티션까지 읽었는지 기록하여 다음 읽을 순서부터 데이터를 읽을 수 있게된다.

commit :  각 파티션에 대해 <mark style="color:blue;">**현재 위치를 업데이트하는 동작을 커밋(Commit)**</mark>한다고 한다.

## 아파치 카프카가 데이터 파이프라인으로 적합한 4가지 이유

### 1. 높은 처리량

* 많은 양의 데이터를 묶은 단위로 처리하는 배치로 빠르게 처리할 수 있기 때문에 대용량의 실시간 로그데이터를 처리하는 데에 적합.
* 파티션 단위를 통해 동일 목적의 데이터를 여러 파티션에 분배하고 데이터를 병렬 처리할 수 있다.
* 파티션 개수만큼 컨슈머 개수를 늘려서 동일 시간당 데이터 처리량을 늘릴 수 있다.

### 2. 확장성

* 데이터가 적을 때는 카프카 클러스터의 브로커를 최소한의 개수로 운영하다가 데이터가 많아지면 클러스터의 브로커 개수를 자연스럽게 늘려 스케일 아웃(scale-out) 할 수 있다.
* 반대로 데이터 개수가 적어지고 추가 서버들이 더는 필요없어지면 브로커 개수를 중려 스케일 인 (scale-in)할 수 있다.
* 카프카의 스케일 아웃, 스케일 인 과정은 클러스터의 무중단 운영을 지원

### 3. 영속성

* 카프카는 다른 메시징 플랫폼과 다르게 전송받은 데이터를 메모리에 저장하지 않고 파일 시스템에 저장한다.
* 파일에 쓰기 때문에 느리다고 생각하겠지만 I/O 성눌 향상을 위해 페이지 캐시 영역을 메모리에 따로 생성하여 사용한다.
* 페이지 캐시 메모리 영역을 사용하여 한번 읽은 파일 내용은 메모리에 저장시켰다가 다시 사용하는 방식이기 때문에 카프카가 파일 시스템에 저장하고 데이터를 저장, 전송하더라도 처리량이 높은 것
* 디스크 기반의 파일 시스템을 활용하기 때문에 급작스럽게 종료되더라도 프로세스를 재시작하여 안전하게 데이터를 다시 처리할 수 있음.

### 4. 고가용성

* 3개 이상의 서버들(kafka broker)로 운영되는 카프카 클러스터는 일부 서버에 장애가 발생하더라도 무중단으로 안전하고 지속적으로 데이터를 처리할 수 있다.
* 클러스터로 이루어진 카프카는 데이터의 복제를 통해 고가용성의 특징을 가지게 되었다.
* 프로듀서로 전송받은 데이터를 여러 블로커 중 하나에만 저장하는 것이 아닌 전부 다 저장하는 것
* On-premise, clould 등 브로커 옵션들이 존재함.

